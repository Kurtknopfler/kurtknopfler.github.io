<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线段树与树状数组</title>
      <link href="/2022/02/10/%E8%AE%B0%E5%BD%95/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2022/02/10/%E8%AE%B0%E5%BD%95/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>树状数组与线段树都是非常强大的数据结构，在很多算法题中得到应用，因此需要进行掌握。</p><h4 id="题目特征"><a href="#题目特征" class="headerlink" title="题目特征"></a>题目特征</h4><ul><li><strong>单点更新</strong></li><li><strong>区间查询</strong><br>一般来讲，需要求上述问题的解时，常常会用到<em>线段树</em>或<em>树状数组</em></li></ul><p>需要注意的是，<strong>区间求和</strong>问题还可以用<strong>前缀和</strong>来进行求解，但是<strong>前缀和</strong>的局限之处在于其前缀和数组在初始化之后就固定了，每当更新其中某一个点的信息时，需要重复更新整个前缀和数组，有过多的冗余计算，因此遇到动态更新区间内的点时，无法使用前缀和来进行求解。</p><h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><p>树状数组使用一维数组来表示，结构与操作十分简单，但是其原理证明十分复杂</p><p>树状数组在结构上将数据分为若干层： <strong>数组下标从 1 开始，其二进制表示中有多少个 0 ，就视其为第几层</strong></p><p>这种结构划分使得树状数组从原本普通的一维线性数组变成了一种具有树状层次的数据结构</p><p>而在此划分的基础上，所有第 0 层位置存储的是其原来的数据，所有大于 0 层的位置存放的数据是在此位置之前且尚未被统计过的数据之和</p><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p><strong>操作</strong>：</p><ul><li>push up: 利用子结点的信息来更新当前节点的信息</li><li>build: 在一段区间上初始化线段树</li><li>modify: 单点修改操作</li><li>query: 区间查询操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20220129_AcWing周赛记录</title>
      <link href="/2022/01/29/%E5%91%A8%E8%B5%9B/20220129_acw%E5%91%A8%E8%B5%9B/"/>
      <url>/2022/01/29/%E5%91%A8%E8%B5%9B/20220129_acw%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>本周周赛未能按时参加，因此本篇仅作题目的思考记录以及分析，不涉及成绩总结。</p><h5 id="第一题-处理字符串"><a href="#第一题-处理字符串" class="headerlink" title="第一题:处理字符串"></a>第一题:<a href="https://www.acwing.com/problem/content/4218/">处理字符串</a></h5><p><strong>题目描述:</strong></p><pre><code>给定一个由大小写字母构成的字符串，请你对该字符串进行如下处理：- 将所有大写字母替换为相应的小写字母。- 删除其中的所有元音字母。- 在每个辅音字母前面插入一个 .。字母 a，o，y，e，u，i 为元音字母，其余字母均为辅音字母。注意，y 其实是半元音字母，在本题中规定其为元音字母。</code></pre><p>本题是惯例的签到题，无难度，直接按照题目给定的要求来做即可，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s; <span class="comment">//输入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++) <span class="comment">// 转换为小写</span></span><br><span class="line">        s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">        </span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++) <span class="comment">//删去元音并在其余字符前添加 &#x27;.&#x27;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> t = s[i];</span><br><span class="line">        <span class="keyword">if</span>( t == <span class="string">&#x27;a&#x27;</span> || t == <span class="string">&#x27;e&#x27;</span> || t == <span class="string">&#x27;i&#x27;</span> || t == <span class="string">&#x27;o&#x27;</span> || t == <span class="string">&#x27;u&#x27;</span> || t == <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl; <span class="comment">// 输出答案</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第二题：图中的环"><a href="#第二题：图中的环" class="headerlink" title="第二题：图中的环"></a>第二题：<a href="https://www.acwing.com/problem/content/4219/">图中的环</a></h5><p><strong>题目描述:</strong></p><pre><code>给定一个 n 个点 m 条边的无向图。点的编号从 1 到 n。图中不含重边和自环。请你对给定图进行判断，如果该图是一个有且仅有一个环的连通图，则输出 YES，否则输出 NO。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP第一章笔记</title>
      <link href="/2022/01/24/csapp/chapter1/csapp_cahpter1/"/>
      <url>/2022/01/24/csapp/chapter1/csapp_cahpter1/</url>
      
        <content type="html"><![CDATA[<h3 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h3><p>全书第一章以一种高层次的角度展示了计算机系统的复杂与精巧。简单介绍了计算机的组成、信息的本质、程序的执行过程、计算机软件与硬件如何联系、处理器的工作内容等一些主要涉及计算机内部系统的内容。</p><hr><h4 id="计算机中的信息"><a href="#计算机中的信息" class="headerlink" title="计算机中的信息"></a>计算机中的信息</h4><p>在计算机中，所有的信息都按照二进制(0 和 1)来存储, 称为位(bit), 所有的数字、字符、操作，都按照一定的位序列来排列，计算机能够根据位序列的不同识别不同的符号。<br>所以，所有保存在计算机中的信息对于计算机来说都仅仅是一连串位序列而已，是上下文的顺序赋予了其独特的、人类赋予其的含义。</p><h4 id="程序编译的过程"><a href="#程序编译的过程" class="headerlink" title="程序编译的过程"></a>程序编译的过程</h4><ul><li>hello.c 是我们编写的代码，称为源程序或源代码</li><li><strong>预处理阶段</strong> 预处理器(cpp)根据 hello.c 源代码，向原本的代码中加入头文件引入的地方，将文件存储为 hello.i</li><li><strong>编译阶段</strong>  编译器(ccl) 将 hello.i 翻译为 hello.s，包含一个汇编程序</li><li><strong>汇编阶段</strong> 汇编器(as) 将 hello.s 翻译为机器语言指令， 存储为 hello.o</li><li><strong>链接阶段</strong> 在程序中使用的 C 标准库中的函数可以被连接器(ld) 合并至 hello.o 文件中，最终得到可执行文件 hello</li></ul><h4 id="程序执行的过程"><a href="#程序执行的过程" class="headerlink" title="程序执行的过程"></a>程序执行的过程</h4><p>在编译完成后，我们会得到一个可执行文件 hello</p><ol><li>在执行这个文件时，我们会将文件名通过<strong>键盘</strong>读入计算机中，此时shell 程序将我们输入的字符逐个读取至寄存器，最后统一存放至主存中</li><li>当输入结束时，shell 程序开始加载可执行的 hello 文件。通过一系列指令将hello 目标文件中的代码和数据从磁盘中复制到主存之中</li><li>当所有数据都加载至主存中之后，处理器开始执行 hello 文件中 <strong>main</strong> 程序中的机器语言指令。这些指令将程序输出结果从主存复制到寄存器文件中，最后从寄存器文件中复制到屏幕上，完成整个程序的执行过程。</li></ol><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>通过程序的执行过程，我们可以看到计算机系统花费大量的时间去计算程序，最终将程序结果输出，这其中涉及到大量的信息搬运(即复制)过程。因此，提高程序运行效率的一个重要方式就是要使得这些搬运过程尽可能地快速、高效。<br>因此，使用高速缓存存储器(cache memory) 来存放近期可能会处理的数据可以避免程序从磁盘等地低效的读取数据，从而极大程度上提高程序的性能。</p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>操作系统是一种软件，作用于应用程序与硬件之间。<br>操作系统有两个主要作用：</p><ol><li>防止硬件被失控的应用程序滥用</li><li>向应用程序提供简单且一致的机制来控制复杂并且通常大不相同的硬件设备</li></ol><p>上述的两种功能是操作系统通过三个基本的抽象概念来实现的：<strong>进程</strong>、<strong>虚拟内存</strong>、<strong>文件</strong></p><ul><li><strong>进程</strong><br>进程操作系统对一个正在运行的应用程序的抽象。<br>一个系统上可以同时运行多个进程，每个进程看似独占的使用CPU<br>当一个进程和另一个进程的指令在 CPU 中交错执行时，称这种现象为 <strong>并发运行</strong><br>在绝大多数情况下，一个系统需要运行的进程数目时绝对大于其CPU个数的，而不论在多核系统还是单核系统中，一个CPU都可以看上去同时执行多个程序，这种现象是通过处理器在进程间进行<strong>上下文切换</strong>来实现的<br><strong>进程的切换</strong>是由操作系统 <strong>内核(kernel)</strong> 管理的，内核是操作系统常驻主存的部分</li><li><strong>线程</strong><br><strong>线程</strong>是进程的组成单元，是<strong>进程</strong>的执行单元<br>线程运行于进程的<strong>上下文</strong>之中，所有的线程共享同样的代码与全局数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 154.滑动窗口 题解</title>
      <link href="/2022/01/20/%E9%A2%98%E8%A7%A3/ACW_154_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2022/01/20/%E9%A2%98%E8%A7%A3/ACW_154_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p><a href="https://www.acwing.com/problem/content/156/">题目链接</a></p> <p>给定一个大小为 $n \le 10^6$ 的数组。 </p><p>有一个大小为 $k$ 的滑动窗口，它从数组的最左边移动到最右边。 </p><p>你只能在窗口中看到 $k$ 个数字。 </p><p>每次滑动窗口向右移动一个位置。 </p><p>以下是一个例子：</p><p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，$k$ 为 $3$。</p><table><thead><tr><th align="center">窗口位置</th><th align="center">最小值</th><th align="center">最大值</th></tr></thead><tbody><tr><td align="center">[1  3  -1] -3  5  3  6  7</td><td align="center">-1</td><td align="center">3</td></tr><tr><td align="center">1 [3  -1  -3] 5  3  6  7</td><td align="center">-3</td><td align="center">3</td></tr><tr><td align="center">1  3 [-1  -3  5] 3  6  7</td><td align="center">-3</td><td align="center">5</td></tr><tr><td align="center">1  3  -1 [-3  5  3] 6  7</td><td align="center">-3</td><td align="center">5</td></tr><tr><td align="center">1  3  -1  -3 [5  3  6] 7</td><td align="center">3</td><td align="center">6</td></tr><tr><td align="center">1  3  -1  -3  5 [3  6  7]</td><td align="center">3</td><td align="center">7</td></tr></tbody></table><p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><h4>输入格式</h4><p>输入包含两行。 </p><p>第一行包含两个整数 $n$ 和 $k$，分别代表数组长度和滑动窗口的长度。 </p><p>第二行有 $n$ 个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><h4>输出格式</h4><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><h4>输入样例：</h4><pre><code>8 31 3 -1 -3 5 3 6 7</code></pre><h4>输出样例：</h4><pre><code>-1 -3 -3 -3 3 33 3 5 5 6 7</code></pre><h3 id="算法1">算法1</h3><h4 id="暴力枚举-O-nk">(暴力枚举)  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">nk</span><span class="mclose">)</span></span></span></span></h4><p>最直观最暴力的思想就是：</p><ul><li>维护一个滑动窗口</li><li>每次向队尾添加新数字，将队头数字踢出</li><li>每次遍历窗口，找到最大/最小值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N], q[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( i, j; j &lt; n; j ++, i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> minv = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t = i; t &lt;= j; t ++)</span><br><span class="line">        &#123;</span><br><span class="line">            minv = <span class="built_in">min</span>(minv, a[t]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; minv &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    i = <span class="number">0</span>, j = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( i, j; j &lt; n; j ++, i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> maxv = <span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t = i; t &lt;= j; t ++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxv = <span class="built_in">max</span>(maxv, a[t]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; maxv &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种暴力做法在 k 逼近 n 时将会超时，所以需要进行优化</p><h3 id="算法2">算法2</h3><h4 id="单调队列优化滑动窗口-O-n">(单调队列优化滑动窗口)  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h4><p>可以考虑使用单调队列来对滑动窗口进行优化</p><p>我们考虑如何维护队列的单调性：</p><ul><li>由于每次窗口挪动仅会加入一个数字，去掉一个数字，我们可以在每次挪动窗口时进行队列的调整</li><li>以维护最小值为例，在每次向窗口中加入新数字时，如果当前队尾的元素大于或等于新数字，那么其永远也不会被输出，且会在新数字被踢出队列前出队，因此我们就可以直接在队列中将其删掉</li><li>这样，整个队列就变成了一个单调递增的队列，每次只需要输出队列的头部即可</li></ul><p>这样优化之后，整个算法的时间复杂度可以降为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( q[hh] &lt; i - m + <span class="number">1</span>) hh ++;</span><br><span class="line">        <span class="keyword">while</span>( hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt --;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( i - m + <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( q[hh] &lt; i - m + <span class="number">1</span>) hh ++;</span><br><span class="line">        <span class="keyword">while</span>( hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt --;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( i - m + <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> ACWing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 835.Trie字符串统计 题解</title>
      <link href="/2022/01/20/%E9%A2%98%E8%A7%A3/ACW_835_Trie%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%9F%E8%AE%A1/"/>
      <url>/2022/01/20/%E9%A2%98%E8%A7%A3/ACW_835_Trie%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.acwing.com/problem/content/837/">题目链接</a></p><p>维护一个字符串集合，支持两种操作：</p><p>I x 向集合中插入一个字符串 x；<br>Q x 询问一个字符串在集合中出现了多少次。<br>共有 N 个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。</p><p>输入格式<br>第一行包含整数 N，表示操作数。</p><p>接下来 N 行，每行包含一个操作指令，指令为 I x 或 Q x 中的一种。</p><p>输出格式<br>对于每个询问指令 Q x，都要输出一个整数作为结果，表示 x 在集合中出现的次数。</p><p>每个结果占一行。</p><p><strong>数据范围</strong><br>$1 ≤ N ≤ 2 ∗ 104$</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">I abc</span><br><span class="line">Q abc</span><br><span class="line">Q ab</span><br><span class="line">I ab</span><br><span class="line">Q ab</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h3><h4 id="数组模拟Trie树-O-n"><a href="#数组模拟Trie树-O-n" class="headerlink" title="(数组模拟Trie树)  $O(n)$"></a>(数组模拟Trie树)  $O(n)$</h4><p>可以构造 Trie 前缀树来统计字符串集合中的字符</p><p><strong>Trie树构造思路：</strong></p><ul><li>每个单词从头开始， 依次将单词的每个字符插入到 Trie 树中，在插入过程中，将每个单词的 a - z 映射到 0 - 25</li><li>可以使用 idx 来统计单词个数，第 0 个单词表示Trie 树的根，也表示单词的结尾</li><li>在每个单词的结尾，使用 cnt 数组来统计在此处结尾的单词个数</li></ul><h4 id="空间复杂度：-O-26N"><a href="#空间复杂度：-O-26N" class="headerlink" title="空间复杂度： $O(26N)$"></a>空间复杂度： $O(26N)$</h4><p>由于总共有 26 个单词，因此需要开辟 N * 26 维度的二位数组，这是本题空间的瓶颈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>( !son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cnt[p] ++; <span class="comment">// 在 p 点结尾的单词数量加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>( !son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>( n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, &amp;op, &amp;str);</span><br><span class="line">        <span class="keyword">if</span>( op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法1-1"><a href="#算法1-1" class="headerlink" title="算法1"></a>算法1</h3><h4 id="结构体构造Trie树-O-n"><a href="#结构体构造Trie树-O-n" class="headerlink" title="(结构体构造Trie树)  $O(n)$"></a>(结构体构造Trie树)  $O(n)$</h4><p>使用数组模拟 Trie树 可以有效提高程序运行效率， 但是由于要开辟很多额外的空间，因此空间效率较低</p><p>为了优化空间效率，可以使用结构体来构造 Trie树</p><p>这种 Trie树 的构造思路更加接近 Trie树 的原理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    Node* son[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">Node</span> () &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">            son[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *root;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>( !p-&gt;son[u]) p-&gt;son[u] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        p = p-&gt;son[u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p-&gt;cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>( !p-&gt;son[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = p-&gt;son[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, &amp;op, &amp;str);</span><br><span class="line">        <span class="keyword">if</span>( op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> ACWing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 206.反转链表 题解</title>
      <link href="/2022/01/18/%E9%A2%98%E8%A7%A3/LC_206_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/01/18/%E9%A2%98%E8%A7%A3/LC_206_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目链接</a></p><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="算法1">算法1</h3><h4 id="迭代-O-n">(迭代)  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h4><p>从头结点开始，两个一组翻转，将后一个节点的next指针指向其前一个几点，随后迭代进行</p><p>当后节点为空时，说明整个链表已经反转结束<br>调整头结点的next指针为空即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 迭代版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> a = head, b = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>( b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = b-&gt;next;</span><br><span class="line">            b-&gt;next = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="算法1-2">算法1</h3><h4 id="递归-O-n">(递归)  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h4><p>直接采用递归的思想：reverseList 函数实现的功能是将给定的链表翻转并返回反转后的头结点</p><p>那么我们可以将原链表头结点之后的节点翻转，再将原头结点接到反转后的头结点尾部即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 递归版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> tail = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 168.Excel表列名称 题解</title>
      <link href="/2022/01/18/%E9%A2%98%E8%A7%A3/LC_168_Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/"/>
      <url>/2022/01/18/%E9%A2%98%E8%A7%A3/LC_168_Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述-2">题目描述</h3><p><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/">题目链接</a></p><p>给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="样例">样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：columnNumber = 1</span><br><span class="line">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：columnNumber = 28</span><br><span class="line">输出：&quot;AB&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：columnNumber = 701</span><br><span class="line">输出：&quot;ZY&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：columnNumber = 2147483647</span><br><span class="line">输出：&quot;FXSHRXW&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="算法1-3">算法1</h3><h4 id="进制转换-O-logn">进制转换  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h4><p>思路：<br>数字若是 1-26，说明最后的字符有一位<br>数字若是 27( &gt; 26) - 26 * 26, 说明数字有两位<br>…</p><p>因此，首先根据数字的大小算出总共有多少位<br>最后按照进制转换枚举每一位数字是多少即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>; <span class="comment">// 初始位数为 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> p = <span class="number">26</span>; n &gt; p; p *= <span class="number">26</span>) <span class="comment">// 将p定义为 long long, 防止后面爆 int</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 每次当 n 大于当前的范围时，说明字符的位数应该多 1</span></span><br><span class="line">            n -= p;</span><br><span class="line">            k ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n --; <span class="comment">//最后得到的结果表明 n 位于 26 ^ k, 26 ^ (k + 1) 之间，由于需要与 A-Z 对应，因此可将 n - 1</span></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>( k --)</span><br><span class="line">        &#123;</span><br><span class="line">            res += n % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 21.合并两个有序链表 题解</title>
      <link href="/2022/01/18/%E9%A2%98%E8%A7%A3/LC_21_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/01/18/%E9%A2%98%E8%A7%A3/LC_21_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述-3">题目描述</h3><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">题目链接</a></p><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><hr><h3 id="算法1-4">算法1</h3><h4 id="归并思路-O-n-m">归并思路  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> l1 = list1, l2 = list2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line">        <span class="keyword">while</span>( l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( l1-&gt;val &lt;= l2-&gt;val) p-&gt;next = l1, l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = l2, l2 = l2-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( l1)</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>( l2)</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 24.两两交换链表中的节点 题解</title>
      <link href="/2022/01/18/%E9%A2%98%E8%A7%A3/LC_24_%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/2022/01/18/%E9%A2%98%E8%A7%A3/LC_24_%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述-4">题目描述</h3><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">题目链接</a></p><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><hr><h3 id="算法1-5">算法1</h3><h4 id="遍历一次-时间：O-n-空间：O-1">遍历一次  时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>  空间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h4><p>思路： 借助 dummy 节点，完成以两个节点为一组的节点交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">if</span>( !head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line">        <span class="keyword">while</span>( p &amp;&amp; p-&gt;next &amp;&amp; p-&gt;next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = p-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> b = a-&gt;next;</span><br><span class="line">            a-&gt;next = b-&gt;next;</span><br><span class="line">            b-&gt;next = a;</span><br><span class="line">            p-&gt;next = b;</span><br><span class="line">            p = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 43.字符串相乘 题解</title>
      <link href="/2022/01/18/%E9%A2%98%E8%A7%A3/LC_43_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
      <url>/2022/01/18/%E9%A2%98%E8%A7%A3/LC_43_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述-5">题目描述</h3><p><a href="https://leetcode-cn.com/problems/multiply-strings">题目链接</a><br>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure><h3 id="算法1-6">算法1</h3><h4 id="高精度乘法-O-n-2">(高精度乘法)  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><p>思路： 首先按照低位 --&gt; 高位的顺序将字符串的每一位转化为 <code>int</code> 后，存入<code>vector</code>中</p><p>可以发现， 两个数组相应位置的乘积之和就是最终答案位置之和处位置的答案</p><p>依照此规律将所得数据存好，并去除前导零，输出答案即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">        <span class="type">int</span> n = num1.<span class="built_in">size</span>(), m = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) A.<span class="built_in">push_back</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) B.<span class="built_in">push_back</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">                C[i + j] += A[i] * B[j];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            t += C[i];</span><br><span class="line">            C[i] = t % <span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = C.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( k &amp;&amp; !C[k]) k --;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>( k &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += C[k --] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 69.x的平方根 题解</title>
      <link href="/2022/01/18/%E9%A2%98%E8%A7%A3/LC_69_x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
      <url>/2022/01/18/%E9%A2%98%E8%A7%A3/LC_69_x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述-7">题目描述</h3><p><a href="https://leetcode-cn.com/problems/sqrtx">题目链接</a></p><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：x = 4</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：x = 8</span><br><span class="line">输出：2</span><br><span class="line">解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><hr><h3 id="算法1-8">算法1</h3><h4 id="暴力枚举-O-n">(暴力枚举)  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h4><p>可以从大到小枚举 小于 x 的数字 i， 直到 i * i 小于等于 x 为止，即为我们的要找的答案</p><p>但是这种枚举的方式当 x 很大时，容易超时，因此需要进一步优化</p><h4 id="二分查找-O-logn">(二分查找) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h4><p>可以考虑单调性，由于从 1 ~ x ，所有的数字都是递增的，因此他们的平方也是递增的，所以具有单调性，可以使用二分查找的方式每次缩小一半的查找方式，因此可以达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (<span class="type">long</span> <span class="type">long</span>)l + r + <span class="number">1</span>&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( (<span class="type">long</span> <span class="type">long</span>) mid * mid &lt;= x) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 5.最长回文子串 题解</title>
      <link href="/2022/01/18/%E9%A2%98%E8%A7%A3/LC_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2022/01/18/%E9%A2%98%E8%A7%A3/LC_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述-8">题目描述</h3><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">题目链接</a></p><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><h3 id="算法1-9">算法1</h3><h4 id="暴力枚举-O-n-2">(暴力枚举)  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><p>对于整个字符串，可以有 n 个起点， 每个起点又有 n 个终点，所以枚举所有的情况并找到长度最长的回文子串，复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h4 id="枚举中心点-双指针">(枚举中心点 + 双指针)</h4><p>可以考虑这么思考： 我们每次枚举的不是子串的起点，而是子串的中心点，那么我们只需要分为如下两种情况</p><ul><li>子串的长度为奇数：那么我们枚举的就是中心点，在整个回文子串中，中心点的字符是不需要满足回文条件的，所以只需要向两边扩展，每次比较边界处的两个字符是否相同，若相同那么回文子串可以继续增长；</li><li>子串的长度为偶数：那么需要将中心点纳入回文的条件中对比，每次向边界扩展</li></ul><p>最终，我们取两种情况中的最长者，即可得到最长的回文子串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++;</span><br><span class="line">            <span class="keyword">if</span>( res.<span class="built_in">size</span>() &lt; r - l - <span class="number">1</span>) res = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, r - l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = i, r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++;</span><br><span class="line">            <span class="keyword">if</span>( res.<span class="built_in">size</span>() &lt; r - l - <span class="number">1</span>) res = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, r - l <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 88.合并两个有序数组 题解</title>
      <link href="/2022/01/18/%E9%A2%98%E8%A7%A3/LC_88_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2022/01/18/%E9%A2%98%E8%A7%A3/LC_88_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述-9">题目描述</h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array">题目链接</a></p><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br></pre></td></tr></table></figure><hr><h3 id="算法1-10">算法1</h3><h4 id="递归合并-O-n-m">(递归合并)  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></h4><p>思路：这道题需要在原数组中修改元素，其中nums1 数组的长度已经给定是两个数组元素 n 与 m 的和。<br>因此我们可以反向思维，从 nums1 数组末尾开始放入数据，这样的话不会因为数据大小的问题覆盖其他的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = nums1.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums1[i] &gt;= nums2[j]) nums1[k --] = nums1[i --];</span><br><span class="line">            <span class="keyword">else</span> nums1[k --] = nums2[j --];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( i &gt;= <span class="number">0</span>) nums1[k --] = nums1[i --];</span><br><span class="line">        <span class="keyword">while</span>( j &gt;= <span class="number">0</span>) nums1[k --] = nums2[j --];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 215.第k大的数 题解</title>
      <link href="/2022/01/18/%E9%A2%98%E8%A7%A3/Lc_215_%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0/"/>
      <url>/2022/01/18/%E9%A2%98%E8%A7%A3/Lc_215_%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述-10">题目描述</h3><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">题目链接</a></p><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><h4 id="样例-3">样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><hr><h3 id="算法1-11">算法1</h3><h4 id="排序-O-nlogn">(排序)  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h4><p>最直观的思路是先排序然后选择，那么无论使用什么排序方法最快都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的时间复杂度，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">quick_sort</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[n - k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> x = a[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span> i ++; <span class="keyword">while</span>( a[i] &lt; x);</span><br><span class="line">            <span class="keyword">do</span> j --; <span class="keyword">while</span>( a[j] &gt; x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">quick_sort</span>(a, l, j);</span><br><span class="line">        <span class="built_in">quick_sort</span>(a, j + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="拓展：如果不能递归？">拓展：如果不能递归？</h4><p>迭代快排</p><h3 id="算法2：">算法2：</h3><h4 id="快速选择-O-2n">快速选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h4>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 78.子集 题解</title>
      <link href="/2022/01/16/%E9%A2%98%E8%A7%A3/LC_78_%E5%AD%90%E9%9B%86/"/>
      <url>/2022/01/16/%E9%A2%98%E8%A7%A3/LC_78_%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p><a href="https://leetcode-cn.com/problems/subsets/">题目链接</a></p><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><h4 id="样例">样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><hr><h3 id="算法1">算法1</h3><h4 id="递归搜索-O-n·2-n">(递归搜索)  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">⋅</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n·2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><p>针对数组中的每一个数字，都有两种选择方案：选这个数或不选这个数</p><p>那么我们从第 i = 0 位开始枚举 nums 中的所有数字，当我们枚举至 i = n 时，说明所有的情况都已经枚举结束，返回当前的选择</p><h4 id="C-代码">C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        st = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (<span class="number">11</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(nums, u + <span class="number">1</span>); <span class="comment">// 不选第 u 个数</span></span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[u]);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, u + <span class="number">1</span>); <span class="comment">// 选第 u 个数</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="算法2">算法2</h3><h4 id="二进制优化-O-n·2-n">(二进制优化))  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">⋅</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n·2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><p>使用 <strong>二进制</strong> 的思想对其进行优化后，虽说枚举的方案数量没有改变，但是不用递归而使用迭代，能够有效减少递归栈的空间开销</p><p>算法思想：<br>针对每个数，有 选 与 不选 两种方案，那么总共的方案数就为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种，那么我们就可以用二进制位上的 0 表示当前位置的数字不选， 1 表示当前位置的数字选择</p><p>仅通过遍历从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> (所有数都不选) 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">i = 2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>  (所有数都选)，依次对比每一位的 0、1情况，即可得到所有方案</p><h4 id="C-代码-2">C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i &gt;&gt; j &amp; <span class="number">1</span>) <span class="comment">//当前位置为 1，选</span></span><br><span class="line">                    path.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 50.Pow(x, n) 题解</title>
      <link href="/2022/01/16/%E9%A2%98%E8%A7%A3/LC_50_Pow(x,n)/"/>
      <url>/2022/01/16/%E9%A2%98%E8%A7%A3/LC_50_Pow(x,n)/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode-cn.com/problems/powx-n/">题目链接</a></p><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn ）。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：x = 2.10000, n = 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><hr><h3 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h3><h4 id="快速幂-O-logn"><a href="#快速幂-O-logn" class="headerlink" title="(快速幂)  $O(logn)$"></a>(快速幂)  $O(logn)$</h4><p>如果每次乘以一个 x 来求 x 的 n 次幂的话，那么需要线性的时间，当 n 特别大时，明显效率过低，因此可以二进制的思想将 n 预处理</p><p>思路：</p><ul><li>借助二进制的思想， n 的二进制表示就表明了 n 可以由 2 的多少次幂组成，那么我们可以预处理 $2^0, 2^1, 2^2 …. $ </li><li>整体的时间复杂度将会缩减至 $logn$</li></ul><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">        <span class="type">bool</span> is_minus = n &lt; <span class="number">0</span>; <span class="comment">// 如果幂为负数， 先按照正数计算最后求其倒数即可</span></span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( LL k = <span class="built_in">abs</span>((LL) n); k ; k &gt;&gt;= <span class="number">1</span>) <span class="comment">// 从 k 的第零位开始枚举，看当前位置是否为 1，若为1则应乘上 x^(2^i)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( k &amp; <span class="number">1</span>) </span><br><span class="line">                res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( is_minus) res = <span class="number">1</span> / res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 53.最大子数组和 题解</title>
      <link href="/2022/01/16/%E9%A2%98%E8%A7%A3/LC_53_%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2022/01/16/%E9%A2%98%E8%A7%A3/LC_53_%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述-6">题目描述</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">题目链接</a></p><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><h4 id="样例-2">样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">                                                                                                                                                                                                                                                                                                      </span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><hr><h3 id="算法1-7">算法1</h3><h4 id="动态规划-O-n">(动态规划)  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h4><p>由于本题需要求数组中最大子数组的和，那么如果暴力枚举区间的起点、终点的话，需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的时间复杂度</p><p>同时，我们能够看出，数组中每个位置代表的不仅仅是一种情况，而是一类状态的情况总和，因此可以考虑使用动态规划的思想</p><p>思路：</p><ul><li>可以定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>数组来表示以 i 结尾的位置最大子数组的和</li><li>根据定义，我们可以分析得到:<ul><li>若区间长度为 1， 那么 f[i] = nums[i];</li><li>若区间长度大于 1， 那么 f[i] = f[i - 1] + nums[i]</li></ul></li></ul><p>因此，可以得到动态规划的转移方程为：<br>$ f[i] = max(f[i - 1] + nums[i], nums[i])$</p><p>同时，我们可以发现：</p><p>不必开辟 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的额外空间，只需要两个变量动态更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 即可</p><p><img src="/lcimg/lc53_1.png" alt="lc53_1"></p><h4 id="C-代码">C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>, ans = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = <span class="built_in">max</span>(pre + nums[i], nums[i]);</span><br><span class="line">            ans = <span class="built_in">max</span>(pre, ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 71.简化路径 题解</title>
      <link href="/2022/01/15/%E9%A2%98%E8%A7%A3/LC_71_%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
      <url>/2022/01/15/%E9%A2%98%E8%A7%A3/LC_71_%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode-cn.com/problems/simplify-path/">题目链接</a></p><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘&#x2F;‘ 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’&#x2F;&#x2F;‘）都被视为单个斜杠 ‘&#x2F;‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件&#x2F;目录名称。</p><p>请注意，返回的 规范路径 必须遵循下述格式：</p><p>始终以斜杠 ‘&#x2F;‘ 开头。<br>两个目录名之间必须只有一个斜杠 ‘&#x2F;‘ 。<br>最后一个目录名（如果存在）不能 以 ‘&#x2F;‘ 结尾。<br>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。<br>返回简化后得到的 规范路径 。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：path = &quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：path = &quot;/../&quot;</span><br><span class="line">输出：&quot;/&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：path = &quot;/home//foo/&quot;</span><br><span class="line">输出：&quot;/home/foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：path = &quot;/a/./b/../../c/&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h3><h4 id="模拟-O-n"><a href="#模拟-O-n" class="headerlink" title="(模拟)  $O(n)$"></a>(模拟)  $O(n)$</h4><p>本题本质上是模拟进入 Unix 系统路径的方法，只需要按照规定将所有步骤执行，遍历一遍字符串即可</p><p>需要注意的是一些边界情况：</p><ul><li>在根目录时输入了 <code>/../</code>, 这种情况下需要返回根目录<code>/</code>，因为根目录无法再向上回到更上级的目录</li><li>有些路径包含连续的 <code>////</code>, 应该去掉重复的 <code>/</code></li></ul><p>思路： 可以看出，所有的有效路径都是在两个<code>/</code>中产生的，所以我们应该将 <code>/</code>视为分界点，统计在两个 <code>/</code> 之间出现的字符串，按照规定模拟即可</p><p>规则：</p><ul><li>当两个<code>/</code>之间的字符串为 <code>.</code> 或 为空时，说明要么表示在当前目录不动，要么表示有多个<code>/</code>,这种情况不必更新最终路径</li><li>当两个<code>/</code>之间的字符串为 <code>..</code>时，说明不仅不应该加入新的路径，反而应当将最终路径向前回退至上一个 <code>/</code></li><li>当<code>/</code>之间的字符串为正常路径时，应当更新最终路径，需要注意的时每次更新最终路径时按照<code>/路径名</code>的方式更新</li></ul><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">simplifyPath</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        string res, seg;</span><br><span class="line">        <span class="keyword">if</span>( path.<span class="built_in">back</span>() != <span class="string">&#x27;/&#x27;</span>) path += <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : path)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( c != <span class="string">&#x27;/&#x27;</span>) seg += c;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( seg == <span class="string">&quot;..&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>( res.<span class="built_in">size</span>() &amp;&amp; res.<span class="built_in">back</span>() != <span class="string">&#x27;/&#x27;</span>) res.<span class="built_in">pop_back</span>(); <span class="comment">//每当到尚未回退至上一个/时，持续回退</span></span><br><span class="line">                    <span class="keyword">if</span>(res.<span class="built_in">size</span>()) res.<span class="built_in">pop_back</span>(); <span class="comment">// 删去剩余的一个 /</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( seg != <span class="string">&quot;.&quot;</span> &amp;&amp; seg != <span class="string">&quot;&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//当 seg 为正常路径时，更新最终路径</span></span><br><span class="line">                    res += <span class="string">&#x27;/&#x27;</span> + seg;</span><br><span class="line">                &#125;</span><br><span class="line">                seg.<span class="built_in">clear</span>(); <span class="comment">//每次需要清空两个 / 之间的字符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( res.<span class="built_in">empty</span>()) res += <span class="string">&#x27;/&#x27;</span>;  <span class="comment">//如果执行完之后 res 为空，说明他在当前路径，应该加上 /</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 60.排列序列 题解</title>
      <link href="/2022/01/15/%E9%A2%98%E8%A7%A3/LC_60_%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/"/>
      <url>/2022/01/15/%E9%A2%98%E8%A7%A3/LC_60_%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode-cn.com/problems/permutation-sequence/">题目链接</a></p><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n &#x3D; 3 时, 所有排列如下：</p><p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定 n 和 k，返回第 k 个排列。</p><p> </p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 3, k = 3</span><br><span class="line">输出：&quot;213&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 4, k = 9</span><br><span class="line">输出：&quot;2314&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n = 3, k = 1</span><br><span class="line">输出：&quot;123&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= n &lt;= 9</span><br><span class="line">1 &lt;= k &lt;= n!</span><br></pre></td></tr></table></figure><hr><h3 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h3><h5 id="枚举-O-n-2"><a href="#枚举-O-n-2" class="headerlink" title="(枚举)  $O(n^2)$"></a>(枚举)  $O(n^2)$</h5><p>由于需要快速计算出从小到大第 k 位的排列值，那么我们可以考虑当确定了 i 位数字时，排列数目的变化；</p><p>首先，当任意一位数字都未确定时，总共排列的数目为 $n!$种</p><p>每确定一位数字， 剩余的排列数就会相应的变为 $(n - 1)!$种</p><p>那么，我们可以从小到大枚举尚未选择的最小数字，若当前第 k 个排列大于剩余的排列数 $(n - i)!$，那么说明第 k 个排列应该在以更大数字为起始的排列当中</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">st</span><span class="params">(n)</span></span>;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - i; j ++) f *= j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( !st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( k &lt;= f)</span><br><span class="line">                    &#123;</span><br><span class="line">                        st[j] = <span class="literal">true</span>;</span><br><span class="line">                        res += (j + <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k -= f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 81.搜索旋转数组 II 题解</title>
      <link href="/2022/01/14/lc-81/"/>
      <url>/2022/01/14/lc-81/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">题目链接</a></p><p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p><p>你必须尽可能减少整个操作步骤。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><hr><h3 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h3><h5 id="暴力枚举-O-n"><a href="#暴力枚举-O-n" class="headerlink" title="(暴力枚举)  $O(n)$"></a>(暴力枚举)  $O(n)$</h5><p>由于题目数据范围比较小，因此可以直接暴力枚举数组中每个元素，并于目标值进行比较即可</p><hr><h3 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h3><h5 id="二分查找-O-log-n"><a href="#二分查找-O-log-n" class="headerlink" title="(二分查找)  $O(log(n))$"></a>(二分查找)  $O(log(n))$</h5><p>这道题是 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/">LeetCode 33.搜索旋转排序数组</a> 的变种；<br>在 LC_33 中，数据保证了数组中不含有重复的元素，那么整个数组是具有二段性的，因此可以直接使用二分查找</p><p>在本题中，由于数组中含有重复元素，在旋转之后有可能会破坏原有的二分性质，因此需要在二分之前进行预处理，去掉某一部分中的重复元素，之后即可进行二分查找</p><p>如图所示，在二分时会出现无法判断属于前半部分还是后半部分的情况，因此需要对其中的一个部分删去重复元素，还原二分性质</p><p><img src="/lcimg/lc81_1.png" alt="lc81_1"></p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( nums[r] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.<span class="built_in">size</span>() == <span class="number">1</span>)   <span class="keyword">return</span> target == nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( k &amp;&amp; nums[k] == nums[<span class="number">0</span>]) k --, nums.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( nums[mid] &gt;= nums[<span class="number">0</span>]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>( r &lt; n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="built_in">find</span>(nums, <span class="number">0</span>, r, target) || <span class="built_in">find</span>(nums, r + <span class="number">1</span>, n - <span class="number">1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> flag = <span class="built_in">find</span>(nums, <span class="number">0</span>, r, target);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 31.下一个排列 题解</title>
      <link href="/2022/01/13/%E9%A2%98%E8%A7%A3/LC_31_%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
      <url>/2022/01/13/%E9%A2%98%E8%A7%A3/LC_31_%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><hr><h3 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h3><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>为了找到下一个排列，我们需要对序列的性质进行分析：</p><p>何为最小的下一个排列？ </p><p>如果我们将一个排列视为一个数字，此时从排列的左至右，可以视为数字的高位至低位</p><p>那么为了找到大于当前数字的最小数字，我们需要保证数字的高位尽可能不调整，调整低位的数字。</p><p>因此，可以从后往前遍历数列，找到从后往前第一个发生数列下降的位置 k。</p><p>此时，将 k - 1 处的值视为 x， 我们需要在 k - 1 之后的位置中找到一个大于 x 的最小值，将其与 x 互换位置，随后将 k - 1 之后的序列逆序即可</p><h5 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h5><p>为什么这个算法是正确的呢？</p><p>首先，我们能够保证排列的高位是尽可能不做调整的，我们找到的是整个序列中升序和降序的交界点，那么此时交界点（设为 k）之前是升序排列的，交界点之后是降序排列的，明显交界点的位置是整个序列的最大值。</p><p>那么，此时如果我们将 k 处的值向前交换，那么明显会得到更大的排列，但是很显然不一定能够得到最小的排列。<br>因此，我们需要在 k 之后寻找一个大于 k - 1 处值的最小值并交换。</p><p>此时，我们可以保证 k 之前的序列已经是最小的了，那么序列之后的呢？</p><p>由于我们交换了大于 k - 1 的最小值，交换之后的序列明显也是降序的， 那么为了得到最小的下一个排列，我们可以将 k - 1 之后降序的序列翻转，可以得到升序序列，即可得到最小的下一个排列</p><h4 id="时间复杂度-O-n"><a href="#时间复杂度-O-n" class="headerlink" title="时间复杂度  $O(n)$"></a>时间复杂度  $O(n)$</h4><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">0</span> &amp;&amp; nums[k] &lt;= nums[k - <span class="number">1</span>]) k --;</span><br><span class="line">        <span class="keyword">if</span>( k &lt;= <span class="number">0</span>) <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 特殊情况，如果整个序列是降序的，说明此时的序列是最大排列，将其转化为最小序列</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 此时 k 所在的位置，就是从数列开头的升序最后一个位置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在 t 的位置后面找到比其前一个位置稍大一点的数，交换位置即可</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// 由于 t 之前是升序排列， t 之后是降序排列，因此将 t 之前一个位置交换之其后的那个位置后，后面的序列至少不会变化，此时再将 t 之后的序列逆序，即可得到下一个排列</span></span><br><span class="line">            <span class="type">int</span> t = k;</span><br><span class="line">            <span class="keyword">while</span>( t &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[t] &gt; nums[k - <span class="number">1</span>]) t ++;</span><br><span class="line">            <span class="built_in">swap</span>(nums[k - <span class="number">1</span>], nums[t - <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 42.接雨水 题解</title>
      <link href="/2022/01/01/%E9%A2%98%E8%A7%A3/LC_42_%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2022/01/01/%E9%A2%98%E8%A7%A3/LC_42_%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例如图：</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>示例 1：<br><img src="/lcimg/lc42_1.png" alt="lc42_1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h3><h5 id="线性扫描三次-O-n"><a href="#线性扫描三次-O-n" class="headerlink" title="(线性扫描三次)  $O(n)$"></a>(线性扫描三次)  $O(n)$</h5><p>对于每一个柱子来说，若他要能够接住雨水，那么必须满足在这根柱子的左右两边存在着高度高于他的其他柱子，这样才有可能形成凹槽接住雨水。</p><p>那么可以通过两次遍历整个数组，第一次遍历存储每个位置左侧的最高柱子，第二次遍历存储每个位置右侧的最高柱子</p><p>最终，预处理完左右两侧的柱子之后，我们可以最后遍历所有的柱子，根据每个柱子左右两侧的最大柱子计算以该柱子之上可以接住的雨水即可</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_max</span><span class="params">(n)</span>, <span class="title">right_max</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        left_max[<span class="number">0</span>] = height[<span class="number">0</span>], right_max[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">            left_max[i] = <span class="built_in">max</span>(left_max[i - <span class="number">1</span>], height[i]); <span class="comment">// 预处理左侧最高柱子</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            right_max[i] = <span class="built_in">max</span>(right_max[i + <span class="number">1</span>], height[i]); <span class="comment">// 预处理右侧最高柱子</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            res += <span class="built_in">min</span>(left_max[i], right_max[i]) - height[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于与这种方法来说，思路比较容易理解，但是借助了额外 $O(n)$ 的空间，并且遍历了三遍数组，可以进行进一步的优化</p><hr><h3 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h3><h5 id="利用单调栈来优化-O-n"><a href="#利用单调栈来优化-O-n" class="headerlink" title="(利用单调栈来优化)  $O(n)$"></a>(利用单调栈来优化)  $O(n)$</h5><p>可以考虑使用一个单调递减的单调栈来维护每一个柱子左侧柱子的信息。</p><p>可以这么考虑： 当前的柱子若要接住雨水，他必须与右侧、左侧比他高的柱子形成凹槽， 那么我们使用一个单调递减的栈，每次遇到一个新柱子时，将现在栈顶的柱子高度与即将入栈的新柱子进行对比，可以有如下情况</p><ol><li>如果当前的遇到的新柱子高度 <strong>高于</strong> 当前栈顶柱子的高度， 说明有可能会形成凹槽，此时应当将栈顶的柱子弹出，作为凹槽的底部计算面积， 记为 top</li><li>如果弹出 top 后，当前栈仍然不为空，说明以 top 为底的凹槽左边仍然存在着较高的柱子，那么可以形成一个完整的槽， 此时可以接雨水的量就可以使用三者的高度、横坐标来计算了</li><li>如果弹出 top 后，栈空，说明此时这个凹槽缺了口，不能接雨水，不考虑这种情况</li></ol><h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;  i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( stk.<span class="built_in">size</span>() &amp;&amp; height[i] &gt; height[stk.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> top = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>( stk.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                res += (<span class="built_in">min</span>(height[stk.<span class="built_in">top</span>()], height[i]) - height[top]) * (i - stk.<span class="built_in">top</span>() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而，单调栈的思路虽然很巧妙，但是不容易想到，同时仍然使用了额外 $O(n)$ 的空间，因此考虑另外的方法来进行空间上的优化</p><h3 id="算法3"><a href="#算法3" class="headerlink" title="算法3"></a>算法3</h3><h5 id="利用双指针来优化-O-n"><a href="#利用双指针来优化-O-n" class="headerlink" title="(利用双指针来优化)  $O(n)$"></a>(利用双指针来优化)  $O(n)$</h5><p>由第一种算法启发，我们可以考虑不使用额外的数组来存储每个柱子左右两端的更高柱，转而考虑使用两个指针来维护相应的信息，那么空间将会优化至 <strong>O(1)</strong></p><p>初始时，指定两个指针分别指向数组的开头和末尾，每次比较两个指针所指的柱子高度。若要接住雨水的话，必然是较小者更能形成凹槽，因此每次取其中较小者作为凹槽的底，计算当前这个短柱子上方可以放多少水，能够存放的水量就是当前左侧最高柱子与当前指向的最低柱子之差。两指针分别向右、向左遍历数组，相遇后停止，可以达到 <strong>O(n)</strong> 的时间复杂度以及 <strong>O(1)</strong> 的空间复杂度</p><h4 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l_max = height[<span class="number">0</span>], r_max = height[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( l_max &lt; r_max)</span><br><span class="line">            &#123;</span><br><span class="line">                res += <span class="built_in">max</span>(<span class="number">0</span>, l_max - height[l]);</span><br><span class="line">                l_max = <span class="built_in">max</span>(l_max, height[l]);</span><br><span class="line">                l ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res += <span class="built_in">max</span>(<span class="number">0</span>, r_max - height[r]);</span><br><span class="line">                r_max = <span class="built_in">max</span>(r_max, height[r]);</span><br><span class="line">                r --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java期末复习之基础概念一</title>
      <link href="/2021/12/26/chapter1/"/>
      <url>/2021/12/26/chapter1/</url>
      
        <content type="html"><![CDATA[<h3 id="JAVA复习——第一章"><a href="#JAVA复习——第一章" class="headerlink" title="JAVA复习——第一章"></a>JAVA复习——第一章</h3><h4 id="1-1-计算机、程序和Java概述"><a href="#1-1-计算机、程序和Java概述" class="headerlink" title="1.1 计算机、程序和Java概述"></a>1.1 计算机、程序和Java概述</h4><hr><h5 id="计算机概述"><a href="#计算机概述" class="headerlink" title="计算机概述"></a>计算机概述</h5><ul><li>计算机是<strong>存储</strong> 和 <strong>处理</strong>数据的电子设备</li><li>计算机包括<strong>硬件(Hardware)</strong> 和 <strong>软件(Software)</strong> 两部分</li><li>一般来说，<strong>硬件</strong>指计算机中<strong>可见</strong>的物理部分，即对于人类来说可以在现实世界中看到、触摸到的实体。通常来讲，计算机的硬件主要有如下几种：<ul><li>中央处理器(CPU)</li><li>内存</li><li>存储设备(用来存储计算机中的数据)</li><li>输入设备(用来让人类想计算机中输入数据)</li><li>输出设备(用来展示计算机中的数据)</li><li>通信设备(用来与互联网、其他计算机连接)<br>  <img src="/1_1.png" alt="1_1"></li><li>上述计算机中的硬件借助总线(bus)实现互联</li><li>在一般计算机中，总线搭建在<strong>主板</strong>上，而主板是一块连接计算机各个部分的电路板</li></ul></li><li>软件则是一些<strong>指令</strong>，用来操控计算机</li></ul><h5 id="硬件概述"><a href="#硬件概述" class="headerlink" title="硬件概述"></a>硬件概述</h5><ul><li><p><strong>中央处理器(Central Processing Unit, CPU)<strong>，是计算机的核心和大脑，负责从计算机</strong>内存</strong>获取并执行指令</p><ul><li>关于<strong>时钟</strong><ul><li>CPU内部的<strong>时钟</strong>以固定的速度发射<strong>电子脉冲</strong></li><li><strong>电子脉冲</strong>用于控制和同步计算机各种操作的步调</li><li><strong>时钟</strong>速度越快，表示在单位时间内执行的指令越多</li><li><strong>时钟</strong>速度的计量单位是<strong>赫兹(hertz, Hz)</strong>, 一赫兹相当于每秒钟发射一个电子脉冲，目前的CPU运行速度都是GHz级别</li></ul></li><li>关于<strong>核</strong><ul><li><strong>核(core)</strong> 是CPU内部实现指令读取以及执行的部分，目前的CPU中包含多个核，每个核之间相互独立</li></ul></li></ul></li><li><p><strong>比特与字节</strong></p><ul><li>比特(bit), 在计算机中又称为<strong>位</strong>，表示二进制数</li><li>字节(byte)，是计算机中最小的存储单元，每个字节由<strong>8个比特</strong>构成</li><li>在计算机存储系统中，小写<strong>b</strong>表示比特(bit)，大写<strong>B</strong>表示字节(byte)</li></ul></li><li><p><strong>内存</strong></p><ul><li>计算机的内存是一个有序的字节序列，用来存储计算机程序以及程序<strong>运行时</strong>需要的数据</li><li>这意味着，计算机大部分数据平时存储于计算机的<strong>存储设备</strong>中，每当程序需要运行时，才会将所需要的顺序读取进入到内存中</li><li>在内存中，每一个字节都有一个<strong>唯一的地址</strong>，使用这个地址就可以确定该字节在内存中的具体位置，方便存储和获取数据</li><li>由于内存可以按照任意顺序读取字节，因此内存也被称为<strong>随机访问存储器(Random-Access Memory, RAM)</strong></li><li>在内存中的字节其内容永远<strong>非空</strong>，但是其内容有可能是没有任何意义的</li><li><strong>内存(RAM)</strong> 是一种非常容易丢失的数据保存形式，每当断电时，储存在内存中的信息就将会永久丢失</li><li>计算机程序和数据平时放在<strong>存储设备</strong>中，每当需要使用时才会从计算机存储设备中加载进入<strong>内存</strong>中</li><li>CPU从内存中读取数据比从存储设备中读取数据<strong>快</strong>很多</li></ul></li><li><p><strong>编程语言</strong></p><ul><li>关于<strong>机器语言</strong><ul><li><strong>机器语言</strong> 是指计算机能够理解的语言，即计算机<strong>内嵌的基本指令集</strong>，机器语言因计算机的类型的不同而有所差异</li><li><strong>机器语言</strong>都是以二进制的形式来存储的，并且必须以二进制代码输入指令</li></ul></li><li>关于<strong>汇编语言</strong><ul><li><strong>汇编语言</strong>是早期的变成语言，非常接近机器语言，并且使用汇编语言需要了解CPU如何工作</li><li><strong>汇编语言</strong>使用<strong>助记符</strong>表示每一条机器语言指令</li><li>由于计算机不理解<strong>汇编语言</strong>，需要借助<strong>汇编器</strong>将汇编语言程序转换为机器代码<br><img src="/1_2.png" alt="1_2"></li></ul></li></ul></li><li><p><strong>高级语言</strong></p><ul><li><strong>高级语言</strong>更加接近于人类可理解的语言</li><li>使用<strong>高级语言</strong>编写的程序称为<strong>源代码(Source code)<strong>或</strong>源程序(Source program)</strong></li><li>高级语言借助<strong>解释器</strong>或<strong>编译器</strong>来运行</li><li><strong>解释器</strong>逐行从源代码中读取语句，每读取一行就将其<strong>翻译</strong>成为机器代码并立即执行<br><img src="/1_3.png" alt="1_3"></li><li><strong>编译器</strong>将整个源代码<strong>翻译</strong>成为机器代码文件，并执行该文件<br><img src="/1_4.png" alt="1_4"></li></ul></li><li><p><strong>操作系统</strong></p><ul><li><strong>操作系统</strong>是<strong>软件</strong>，是运行在计算机上的<strong>程序</strong></li><li><strong>操作系统</strong>可以<strong>管理</strong>和<strong>控制</strong>计算机的活动</li><li><strong>操作系统</strong>的主要任务：<ul><li><strong>控制</strong>和<strong>监视</strong>系统任务</li><li><strong>分配</strong>和<strong>调配</strong>系统资源</li><li><strong>调度操作</strong><ul><li><strong>多道程序设计(multiprogramming)<strong>允许多个程序</strong>共享</strong>同一个CPU<strong>同时</strong>运行</li><li><strong>多线程</strong>允许<strong>单个程序</strong>同时执行<strong>多个任务</strong></li><li><strong>多处理</strong>使用<strong>多个处理器</strong>来<strong>并行</strong>运行<strong>多个程序</strong></li></ul></li></ul></li></ul></li></ul><h5 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h5><ul><li><strong>JDK(Java Development Toolkit)<strong>是用于</strong>开发</strong>和<strong>运行</strong>Java程序的软件</li><li><strong>JRE(Java Runtime Environment)<strong>是</strong>运行</strong>Java程序的<strong>程序</strong></li><li>Java源文件的扩展名为 <strong>.java</strong>, 通过编译器编译后生成<strong>字节码</strong>文件，扩展名为 <strong>.class</strong>, 最后由<strong>JVM java虚拟机</strong>来读取和解释以及执行</li><li><strong>JVM， java虚拟机</strong>是一个用来解释java字节码的程序，因此所有安装了JVM的平台都可以随意运行java程序<br><img src="/1_5.png" alt="1_5"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra SPFA Bellman_ford三种图论算法的模板、应用场景及区别</title>
      <link href="/2021/11/30/dijkstra_spfa_bf%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/11/30/dijkstra_spfa_bf%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<font size="4"><blockquote><p>Dijkstra:</p></blockquote><blockquote><p><kbd><a href="https://www.acwing.com/problem/content/851/">Dijkstra求最短路 I</a></kbd></p><p><kbd><a href="https://www.acwing.com/problem/content/852/">Dijkstra求最短路 II</a></kbd> </p></blockquote></font><hr><ul><li><font size="4">朴素Dijkstra的算法思想:</font></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist); <span class="comment">// 初始化，将图中所有的点距离初始为 负无穷，随后在 dijkstra 的算法过程中更新最短距离;</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 在这里将 标号为 1 的点距离初始为0， 表示 1 号点到 1 号点的距离为 0;</span></span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>; <span class="comment">// 寻找当前集合中距离最小的点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        根据 dijkstra 的定义，很容易知道，第一次循环一定会找到 1 号点， 随后根据 1 号点的距离更新其余点的值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !st[j] &amp;&amp; ( t == <span class="number">-1</span> || dist[t] &gt; dist[j])) <span class="comment">// 如果说当前的点 j 尚未被遍历过，并且 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BFS:</p><p><kbd><a href="https://www.acwing.com/problem/content/846/">走迷宫</a></kbd></p><p><kbd><a href="https://www.acwing.com/problem/content/847/">八数码</a></kbd></p></blockquote><span id="more"></span><hr><ul><li><font size="4">广度优先遍历的通用模板:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(队列不空)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = 队头元素</span><br><span class="line">    遍历队头元素所能到达的元素，并加入队列中</span><br><span class="line">    并根据题目维护不同的额外信息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">队列为空时，说明深度遍历已经结束</span><br></pre></td></tr></table></figure></font></li><li>BFS中通常涉及到上下左右方向的枚举，可以直接使用两个数组dx dy来模拟</li></ul><hr><blockquote><p>树和图的DFS:<br><kbd><a href="https://www.acwing.com/problem/content/848/">数的重心</a></kbd></p><p>树和图的BFS:<br><kbd><a href="https://www.acwing.com/problem/content/849/">图中点的层次</a></kbd></p></blockquote><hr><ol><li><font size="4">树和图的存储方式有邻接表和邻接矩阵两种，稀疏图可以使用邻接表，稠密图则需要使用邻接矩阵存储</font></li><li>邻接表模板:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>遍历模板(DFS 与 BFS 类似):<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = e[i];</span><br><span class="line">    <span class="comment">// 根据DFS BFS的不同，使用不同的具体策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><blockquote><p>拓扑排序:<br><kbd><a href="https://www.acwing.com/problem/content/850/">有向图的拓扑序列</a></kbd></p></blockquote><ul><li>在拓扑排序中，需要借助出度、入度的概念维护相应的信息，并借此通过BFS解题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> SPFA </tag>
            
            <tag> Bellman_ford </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器配置之一</title>
      <link href="/2021/11/18/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B9%8B%E4%B8%80/"/>
      <url>/2021/11/18/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B9%8B%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>以阿里云 ECS 服务器，搭载 Ubuntu 20.04系统为例，分享我在使用服务器时的一些配置</p><h2 id="添加子用户"><a href="#添加子用户" class="headerlink" title="添加子用户"></a>添加子用户</h2><p>购买了阿里云服务之之后，系统会分配给我们 <em>root</em> 用户的权限。但是在开发过程中，可能出现误操作删除某些配置、系统文件而导致服务器崩溃的现象。</p><p>因此日常的代码开发应当在 <em>子用户</em> 中进行，防止误操作而删除某些关键文件。</p><h5 id="配置子用户步骤如下："><a href="#配置子用户步骤如下：" class="headerlink" title="配置子用户步骤如下："></a>配置子用户步骤如下：</h5><ul><li>以 <em>root</em> 用户登入服务器</li><li>终端中输入 <code>adduser NewUsername</code></li><li>随后按照提示操作即可添加新的子用户</li></ul><p>需要注意的是，此时添加的子用户并不具有 <em>sudo</em> 权限, 因此要给新加入的用户添加 <em>sudo</em> 权限</p><h5 id="添加-sudo-权限："><a href="#添加-sudo-权限：" class="headerlink" title="添加 sudo 权限："></a>添加 <em>sudo</em> 权限：</h5><ul><li>首先输入 <code>cd ..</code> 回到根目录</li><li>在根目录中输入 <code>cd etc/sudoers.d/</code> 进入 <em>sudo</em> 权限配置文档</li><li>使用 <code>vim</code> 命令创建文件，不需要加入后缀名</li><li>在新创建的文件中输入 <code>Username ALL=(ALL) ALL</code> 保存后退出</li></ul><p>经过上述操作，成功在云服务器上添加了具有 <em>sudo</em> 权限的子用户，以后就不用登陆 <em>root</em> 用户进行开发了，直接在此处开发即可</p><h2 id="配置-SSH-免密登录"><a href="#配置-SSH-免密登录" class="headerlink" title="配置 SSH 免密登录"></a>配置 SSH 免密登录</h2><p>使用阿里云时，每次进入服务器都要<code>进入网页-&gt;登陆账号-&gt;进入服务器</code>，步骤繁琐且麻烦，可以考虑配置 SSH 免密登录来登入云服务器</p><ul><li>进入 <code>c:\User\你的用户名\.ssh</code> 中</li><li>在此目录下输入命令 (需要linux系统， 若使用的是Win，可以使用 Git Bash等其余工具) <code>ssh genkey</code>，来生成本机的 ssh 密钥</li><li>生成结束后，可以在 <code>.ssh</code> 文件夹中看到 <code>id_rsa</code> ,<code>id_rsa.pub</code>等文件，其中 <code>id_rsa</code> 是属于个人的私钥，不要透露给别人， 而<code>id_rsa.pub</code>是本地的公钥，可以共享给别的服务器，达到免密登录的效果</li><li>接下来给我们的云服务器重命名: 输入<code>vim config</code>, 在 <code>.ssh</code>文件夹中创建config文件</li><li>在 config 中输入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host myserver // &#x27;myserver&#x27;就是我们云服务器的别名，可以任意取</span><br><span class="line">    HostName xx.xxx.xxx.xx //hostname后的内容即为云服务器的公网 ip</span><br><span class="line">    User username  // username 就是登录至云服务器的用户名，设置为上一步新建的用户</span><br></pre></td></tr></table></figure></li><li>配置好之后，输入 <code>ssh-copy-id myserver</code> 即可远端一键配置 ssh免密登录</li></ul><p>在配置好免密登录后， 在本地终端中 <code>ssh myserver</code> 即可一键登陆云服务器进行开发啦！<br>Enjoy it ！</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 云服务器 </tag>
            
            <tag> SSH </tag>
            
            <tag> tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20211106刷题记录</title>
      <link href="/2021/11/06/1106record/"/>
      <url>/2021/11/06/1106record/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DFS:<br><kbd><a href="https://www.acwing.com/problem/content/844/">排列数字</a></kbd><br><kbd><a href="https://www.acwing.com/problem/content/845/">n-皇后</a></kbd> </p></blockquote><hr><ol><li>深度优先搜索通常需要使用布尔值来记录某个元素是否被遍历过 </li><li>深度优先搜索需要注意状态的回溯, 每当进入更深层的DFS时,需要在进入之前改变元素的遍历状态, 当从更深层DFS中弹出时, 需要将之前改变的元素状态复位;</li><li>对于n皇后之类的棋盘问题，可以考虑使用建立坐标系的方式构建直线来使用对角线、反对角线等辅助线来解题。</li></ol><blockquote><p>BFS:<br><kbd><a href="https://www.acwing.com/problem/content/846/">走迷宫</a></kbd><br><kbd><a href="https://www.acwing.com/problem/content/847/">八数码</a></kbd></p></blockquote><span id="more"></span><hr><ul><li>广度优先遍历的通用模板:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(队列不空)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = 队头元素</span><br><span class="line">    遍历队头元素所能到达的元素，并加入队列中</span><br><span class="line">    并根据题目维护不同的额外信息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">队列为空时，说明深度遍历已经结束</span><br></pre></td></tr></table></figure></li><li>BFS中通常涉及到上下左右方向的枚举，可以直接使用两个数组dx dy来模拟</li></ul><hr><blockquote><p>树和图的DFS:<br><kbd><a href="https://www.acwing.com/problem/content/848/">数的重心</a></kbd></p><p>树和图的BFS:<br><kbd><a href="https://www.acwing.com/problem/content/849/">图中点的层次</a></kbd></p></blockquote><hr><ol><li>树和图的存储方式有邻接表和邻接矩阵两种，稀疏图可以使用邻接表，稠密图则需要使用邻接矩阵存储</li><li>邻接表模板:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>遍历模板(DFS 与 BFS 类似):<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = e[i];</span><br><span class="line">    <span class="comment">// 根据DFS BFS的不同，使用不同的具体策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><blockquote><p>拓扑排序:<br><kbd><a href="https://www.acwing.com/problem/content/850/">有向图的拓扑序列</a></kbd></p></blockquote><ul><li>在拓扑排序中，需要借助出度、入度的概念维护相应的信息，并借此通过BFS解题。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20211105刷题记录</title>
      <link href="/2021/11/05/1105record/"/>
      <url>/2021/11/05/1105record/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Trie 树:<br><kbd><a href="https://www.acwing.com/problem/content/837/">字符串统计</a></kbd><br><kbd><a href="https://www.acwing.com/problem/content/145/">最大异或对</a></kbd> </p><p>并查集:<br><kbd><a href="https://www.acwing.com/problem/content/838/">合并集合</a></kbd><br><kbd><a href="https://www.acwing.com/problem/content/839/">连通块中点的数量</a></kbd><br><kbd><a href="https://www.acwing.com/problem/content/242/">食物链</a></kbd></p><p>堆:<br><kbd><a href="https://www.acwing.com/problem/content/841/">模拟堆</a></kbd></p><p>哈希:<br><kbd><a href="https://www.acwing.com/problem/content/842/">模拟散列表</a></kbd><br><kbd><a href="https://www.acwing.com/problem/content/843/">字符串哈希</a></kbd></p></blockquote><hr><ol><li>并查集中可以维护额外的信息来解决题目</li><li>模拟堆需要对常规的堆实现任意位置的插入以及删除操作，需要使用额外的映射来维护插入点的顺序</li><li>模拟散列表常用的有两种方法，分别是拉链法与开放寻址法<ul><li>拉链法:散列表中存放的是链表，出现冲突时在对应位置的链表中插入;</li><li>开放寻址法: 散列表为数据大小的2-3倍，当出现重复时，像其后位置依次寻找，若发现空位置则插入;</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 堆 </tag>
            
            <tag> 哈希 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
